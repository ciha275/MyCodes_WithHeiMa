#include<iostream>
#include<vector>
#include<list>
using namespace std;

void test01()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
		cout << v.capacity() << endl;//可以看到vector的容量随着push_back在一定规律下动态扩大
	}
}


/*
3.2.4.1 vector构造函数
vector<T> v; //采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);//构造函数将n个elem拷贝给本身。
vector(const vector &vec);//拷贝构造函数。

3.2.4.2 vector常用赋值操作
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
vector& operator=(const vector  &vec);//重载等号操作符
swap(vec);// 将vec与本身的元素互换。

3.2.4.3 vector大小操作
size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长>度的元素被删除。
capacity();//容器的容量
reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
*/
void printVector(vector<int> v)//写一个通用的输出显示int型vector的方法
{
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
	{
		cout << *it << " ";//对vector内的元素要用迭代器iterator来访问
	}
	cout << endl;
}

void test02()
{
	vector<int> v;//默认构造
	//vector(v.begin(), v.end());//将v[begin(), end())区间中的元素拷贝给本身。
	int arr[] = { 2,3,4,1,9 };
	vector<int> v1(arr, arr + sizeof(arr) / sizeof(int));
	vector<int> v2(v1.begin(), v1.end());
	printVector(v2);
	//vector(n, elem);//构造函数将n个elem拷贝给本身。
	vector<int> v3(10, 100);
	printVector(v3);

	//赋值使用
	vector<int> v4;
	v4.assign(v3.begin(), v3.end());
	printVector(v4);
	//swap(vec);// 将vec与本身的元素互换。
	v4.swap(v2);
	cout << "swap后的v4: " << endl;
	printVector(v4);
	cout << "v4的容器大小： " << v4.size() << endl;

	//empty();//判断容器是否为空
	if (v4.empty())
	{
		cout << "v4为空" << endl;
	}
	else
	{
		cout << "v4不为空" << endl;
	}

	//resize(int num, elem);
	//重新指定容器的长度为num，若容器变长，则以elem值填充新位置，默认为0。如果容器变短，则末尾超出容器长度的元素被删除。
	//v4 目前内容 23419
	v4.resize(10, -1);
	printVector(v4);
	v4.resize(3);
	printVector(v4);

}

//巧用swap收缩空间
void test03()
{
	vector<int> v;
	for (int i = 0; i < 100000; i++)
	{
		v.push_back(i);
	}
	cout << "v的容量： " << v.capacity() << endl;
	cout << "v的大小： " << v.size() << endl;

	v.resize(7);//缩小后大小变了，但容量还是很大，造成浪费
	cout << "v的容量： " << v.capacity() << endl;
	cout << "v的大小： " << v.size() << endl;
	//巧用swap释放空间
	vector<int>(v).swap(v);//“vector<int>(v)”通过v拷贝构造一个匿名对象，就等于v，而且是根据缩小后的v创建，所以这个匿名对象分配的空间就没浪费，将匿名对象与v互换，匿名对象在该行结束就自动释放了
	cout << "v的容量： " << v.capacity() << endl;
	cout << "v的大小： " << v.size() << endl;
}

//reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
void test04()
{
	vector<int> v;
	v.reserve(89564);//如果能大致知道一个需要的大小，先预留，则可减少空间开辟的次数

	int* p = NULL;//随后指向v的地址
	int num = 0;//计数
	for (int i = 0; i < 100000; i++)
	{
		v.push_back(i);
		if (p != &v[0])
		{
			p = &v[0];//如果p不是v的地址，就让p等于其地址
			num++;
		}
		/*所谓动态增加大小，并不是在原空间之后续借新空间（因为无法保证原空间之后尚有可配置的空间），
		而是一块更大的内存空间，然后将原数据拷贝到新空间，并释放原空间。因此，对vector的任何操作，
		一旦引起空间的重新分配，指向原空间的所有迭代器就失效了。*/
		/*所以每一次p等于v的地址就说明在输入十万个数的过程中新分配了一次空间，发生一次数据的拷贝、挪动*/
	}
	cout << num << endl;//可见，不预留空间，靠一次次的动态扩张需要30次的新空间分配，是一笔大开销
	//随意预留了89564的大致空间后，只需要两次开辟，就能存放100000个数了
}


/*
3.2.4.4 vector数据存取操作
at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];//返回索引idx所指的数据，越界时，运行直接报错
front();//返回容器中第一个数据元素
back();//返回容器中最后一个数据元素

3.2.4.5 vector插入和删除操作
insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.
push_back(ele); //尾部插入元素ele
pop_back();//删除最后一个元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
erase(const_iterator pos);//删除迭代器指向的元素
clear();//删除容器中所有元素
*/
void test05()
{
	vector<int> v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(30);
	v.push_back(40);

	cout << "v的front： " << v.front() << endl;
	cout << "v的back： " << v.back() << endl;

	v.insert(v.begin(), 2, 123);//参数一 迭代器， 参数二 插入个数， 参数三 插入内容
	//假设有v1，也是int型，可以把v1的某段插入，如“v.insert(v.begin(), v1.begin(), v1.end())”、
	
	v.pop_back();//删除最后一位
	printVector(v);
	cout << "v的back： " << v.back() << endl;

	v.erase(v.begin());//删除
	printVector(v);

	//全部内容删除
	v.clear();// 二者等价 v.erase(v.begin(), v.end())
	if (v.empty())
	{
		cout << "v空了" << endl;
	}
	else
	{
		cout << "v没空" << endl;
	}
}


//vector的逆序相关
void test06()
{
	//初始化
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}

	//逆序遍历
	//逆序迭代器 reverse_iterator   逆序开头 rbegin()   逆序结尾 rend()
	for (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}


//如何判断一个容器的迭代器是否是随机访问的迭代器
void test07()
{
	vector<int> v;
	for (int i = 0; i < 10; i++)
	{
		v.push_back(i);
	}
	//vector的迭代器是随机访问的迭代器，支持跳跃访问
	vector<int>::iterator itBegin = v.begin();
	itBegin = itBegin + 4;//如果此写法不报错，则这个迭代器是随机访问的迭代器

	//如 list的迭代器就不支持随机访问
	list<int> l;
	for (int i = 0; i < 10; i++)
	{
		l.push_back(i);
	}
	list<int>::iterator litBegin = l.begin();
	//litBegin = litBegin + 4;//此项报错
}

int main()
{
	//test01();
	//test02();
	//test03();
	//test04();
	//test05();
	//test06();
	test07();
}
